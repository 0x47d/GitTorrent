#!/usr/bin/env node

var Chalk = require('chalk')
var DHT = require('bittorrent-dht')
var exec = require('child_process').exec
var fs = require('fs')
var hat = require('hat')
var magnet = require('magnet-uri')
var prettyjson = require('prettyjson')
var spawn = require('child_process').spawn
var Swarm = require('bittorrent-swarm')
var ut_gittorrent = require('ut_gittorrent')
var WebTorrent = require('webtorrent')
var zeroFill = require('zero-fill')

// BitTorrent client version string (used in peer ID).
// Generated from package.json major and minor version. For example:
//   '0.16.1' -> '0016'
//   '1.2.5' -> '0102'
//
var VERSION = require('./package.json').version
  .match(/([0-9]+)/g).slice(0, 2).map(zeroFill(2)).join('')

function die (error) {
  console.error(error)
  process.exit(1)
}

// Gotta enable color manually because stdout isn't a tty.
var chalk = new Chalk.constructor({enabled: true});

var bootstrap = ['dht.gittorrent.org:6881', 'core.gittorrent.org:6881']
var dht = new DHT({
  bootstrap: bootstrap
})

var remotename = process.argv[2]
var url = process.argv[3]
var matches = url.match(/gittorrent:\/\/([a-f0-9]{40})\/(.*)/)
if (matches) {
  var key = matches[1]
  var reponame = matches[2]
  dht.on('ready', function () {
    var val = new Buffer(key, 'hex')
    dht.get(val, function (err, res) {
      if (err) {
        return console.error(err)
      }
      var json = res.v.toString()
      var repos = JSON.parse(json)
      console.warn('\nMutable key ' + chalk.green(key) + ' returned:\n' + prettyjson.render(repos, {keysColor: 'yellow'}))
      get_infohash(repos.repositories[reponame].master)
    })
  })
} else {
  url = url.replace(/^gittorrent:/i, 'git:')
  exec('git ls-remote ' + url, function (err, stdout, stderr) {
    if (err !== null) {
      die(err)
    }
    var lines = stdout.split('\n')
    if (lines.length < 2) {
      die("Didn't get back a single HEAD ref: " + lines)
    }
    var count = lines.length;
    var refs = []
    lines.forEach(function (line) {
      if (line == '') {
        // Last line: publish
        dht.on('ready', function () {
          var refcount = refs.length
          refs.forEach(function (ref) {
            get_infohash(ref.sha, ref.branch)
            refcount--
            if (refcount == 0) {
              process.stdin.setEncoding('utf8')
              process.stdin.on('readable', function () {
                var chunk = process.stdin.read()
                if (chunk === 'capabilities\n') {
                  process.stdout.write('fetch\n\n')
                } else if (chunk === 'list\n') {
                  var refcount = refs.length
                    console.warn('list:\n')
                  refs.forEach(function (ref) {
                    process.stdout.write(ref.sha + ' ' + ref.branch + '\n')
                    console.warn(chalk.red(ref.sha) + ' '
                                 + chalk.green(ref.branch))
                    refcount--
                    if (refcount == 0) {
                      process.stdout.write('\n')
                    }
                  })
                } else if (chunk && chunk != '') {
                  console.warn('unhandled command: ' + chunk)
                }
              })
              process.stdout.on('error', function () {
                // stdout was closed
              })
            }
          })
        })
        return
      }

      var line = line.split('\t')
      var sha = line[0]
      var branch = line[1]
      if (sha.length !== 40) {
        console.warn('Was expecting a 40-byte sha: ' + ref + '\n')
        console.warn('on line: ' + line.join('\t'))
      }
      refs.push({sha : sha, branch : branch})
    })
  })

}

var swarms = {}  // A dictionary mapping sha's to swarms.
var need = {}    // Sha's we need.
var got = {}     // Sha's we got.
var todo = 0     // The number of sha's in need, not in got.
dht.on('peer', function (addr, hash, from) {
  if (!need[hash] && !got[hash]) {
    todo++
    need[hash] = true
    got[hash] = false
  }
  swarms[hash].addPeer(addr)
})

function get_infohash (ref, branch) {
  if (!branch || branch == 'HEAD' || branch == 'refs/heads/master') {
    branch = 'master'
  } else {
    branch = branch.replace(/^refs\//, '')
    branch = branch.replace(/\/head$/, '')
  }

  // We use console.warn (stderr) because git ignores our writes to stdout.
  console.warn('\nOkay, we want to get ' + chalk.yellow(branch) + ': ' +
               chalk.green(sha) + '\n')

  var magnetUri = 'magnet:?xt=urn:btih:' + ref
  var parsed = magnet(magnetUri)
  dht.lookup(parsed.infoHash)

  var peerId = new Buffer('-WW' + VERSION + '-' + hat(48), 'utf8')
  swarms[parsed.infoHash] = new Swarm(parsed.infoHash, peerId)
  swarms[parsed.infoHash].on('wire', function (wire, addr) {
    console.warn('Adding swarm peer: ' + chalk.green(addr) + '\n')
    wire.use(ut_gittorrent())
    wire.ut_gittorrent.on('handshake', function () {
      wire.ut_gittorrent.ask(parsed.infoHash)
    })
    wire.ut_gittorrent.on('receivedTorrent', function (infoHash) {
      var client = new WebTorrent({
        dht: {
          bootstrap: bootstrap
        },
        tracker: false
      })
      client.download(infoHash, function (torrent) {
        console.warn('Downloading git pack with infohash: ' + chalk.green(infoHash) + '\n')
        torrent.on('done', function (done) {
          todo--
          need[ref] = false
          got[ref] = true

          var stream = torrent.files[0].createReadStream()
          var unpack = spawn('git', ['index-pack', '--stdin', '-v', '--fix-thin'])
          stream.pipe(unpack.stdin)
          unpack.stderr.pipe(process.stderr)
          unpack.on('exit', function (code) {
            var targetdir = process.env['GIT_DIR'] || './'

            // Make the parent directories; build the path.
            var target = ['remotes', remotename].concat(branch.split('/'))
            var path = targetdir + '/refs/'
            for (var i = 0; i < target.length - 1; i++) {
              path += target[i] + '/'
              if (!fs.existsSync(path)) {
                fs.mkdirSync(path)
              }
            }
            path += target[target.length - 1]  // Add the base name.

            console.warn('writing to: ' + path)
            var stream = fs.createWriteStream(path)
            stream.once('open', function (fd) {
              stream.write(ref + '\n')
              stream.end()
              if (todo == 0) {
                // These writes are actually necessary for git to finish
                // checkout.
                process.stdout.write('\n\n')
                process.exit()
              }
            })
          })
        })
      })
    })
  })
}
